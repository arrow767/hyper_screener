## Trading module roadmap (спринты)

### Спринт 1 — Архитектура торгового модуля и конфиг

- **Режимы работы**:
  - Определить режимы: `SCREEN_ONLY`, `TRADE_PAPER`, `TRADE_LIVE`.
  - Решить, как текущий скринер будет работать в каждом режиме (при `SCREEN_ONLY` торговля полностью отключена).
- **Интерфейсы модулей**:
  - Спроектировать интерфейсы `TradingModule`, `ExecutionEngine`, `RiskManager` (какие методы, какие DTO).
  - Разделить ответственность: генерация сигналов (от скринера) vs исполнение сделок (execution).
- **ENV-конфиг для торговли** (без реализации логики):
  - `TRADE_ENABLED` (bool), `TRADE_MODE` (`SCREEN_ONLY` / `TRADE_PAPER` / `TRADE_LIVE`).
  - `TRADE_POSITION_SIZE_USD` — базовый размер позиции в $.
  - `TRADE_MAX_RISK_PER_TRADE` — макс. риск на сделку (в $ или % от депо, TBD).
  - `TRADE_MAX_OPEN_POSITIONS` — ограничение по числу одновременных позиций.
  - `TRADE_NATR_PERIOD=14` — период NATR.
  - `TRADE_NATR_TIMEFRAME=5m` — таймфрейм для расчёта NATR.
  - `TRADE_ENTRY_NATR_RANGE` — диапазон входа в NATR (например, `[1,2]`).
  - `TRADE_TP_NATR_LEVELS` — уровни тейк-профитов в NATR (например, `[2,3]`).
  - `TRADE_TP_PERCENTS` — проценты позиции по уровням, например `[50,50]`.
  - `TRADE_SL_TICK_OFFSET` — смещение SL на 1 тик за плотностью (можно как параметр).
  - Базовые лимиты: `TRADE_DAILY_MAX_LOSS`, `TRADE_DAILY_MAX_TRADES` (на будущее).
- **Документация**:
  - Описать все новые env-переменные в `README.md` (секция Trading config).
  - Добавить пояснение по режимам работы и ограничениям (особенно для `TRADE_LIVE`).

### Спринт 1 — Переключение режимов (скринер ↔ торговля)

- **Точка входа**:
  - Продумать, как в `index.ts` создавать/не создавать торговый модуль в зависимости от `TRADE_MODE`.
  - В режиме `SCREEN_ONLY` торговый модуль не инициализируется и не подписывается на сигналы.
- **Интеграция со скринером**:
  - Определить формат сигнала от скринера (структура «крупной заявки» для трейдинга).
  - Продумать, какие фильтры остаются в чистом скринере, а какие должны быть в торговом модуле.

### Спринт 2 — Данные и индикатор NATR(14) на 5m

- **Источник свечей**:
  - Выбрать источник 5m OHLCV (желательно Hyperliquid, чтобы не плодить сторонние зависимости).
  - Определить формат хранения свечей в памяти (per-coin буфер фиксированной длины).
- **Расчёт NATR(14)**:
  - Описать алгоритм расчёта NATR(14) для 5m (на основе ATR/True Range).
  - Продумать прогрев: минимальное количество свечей до начала торговли.
  - Спроектировать обновление NATR по мере прихода новых свечей.
- **API для торгового модуля**:
  - Предусмотреть простой метод типа `getNatr(coin): number | null`.
  - Определить поведение при отсутствии данных (нет свечей/не прогрето).

### Спринт 2 — Диапазоны в NATR

- **Диапазон входа**:
  - Формат конфигурации `TRADE_ENTRY_NATR_RANGE`, например `[1,2]` → вход в диапазоне 1–2 NATR от текущей цены.
  - Описать, как конвертировать `n * NATR` в абсолютный диапазон цены.
- **Диапазон раскидывания лимиток**:
  - Определить, как использовать NATR для размещения лимитных ордеров на вход и на выход.
  - Описать, как проверяем, что цена «подошла» к плотности в рамках диапазона.

### Спринт 3 — Логика сигнала от плотности

- **Базовые правила входа**:
  - Крупная лимитная заявка на **bid** → сценарий **лонг**.
  - Крупная лимитная заявка на **ask** → сценарий **шорт**.
- **Условия активации сигнала**:
  - Минимальная плотность в $ (использовать уже имеющиеся фильтры скринера).
  - Расстояние от текущей цены в NATR (вход/лимитки только в рамках заданного диапазона).
  - Проверка отсутствия противоречащей позиции по этой монете (не открывать второй лонг, если уже есть открытый).
- **Вход лимитом vs маркетом**:
  - Логика «лимиткой от плотности в диапазоне NATR».
  - Логика «по рынку, если цена подошла к плотности по рынку» (в пределах заданного NATR).
  - Сформулировать правила, когда мы предпочитаем лимитный вход, а когда — рыночный.

### Спринт 3 — Объём позиции

- **Расчёт размера**:
  - Использовать `TRADE_POSITION_SIZE_USD` как базу: `contracts = USD / price`.
  - Учитывать плечо и максимально допустимый риск (`TRADE_MAX_RISK_PER_TRADE`).
- **Проверки**:
  - Поведение при слишком большом размере относительно ликвидности/спреда.
  - Что делать при слишком узком диапазоне (частичный вход / отказ от сделки).
  - Должен проверять перед сделкой позицию. Если она уже есть и она максимальная, то мы не заходим в сделку

### Спринт 4 — Execution engine

- **Оркестрация ордеров**:
  - Спроектировать модуль, который умеет:
    - выставлять лимитный ордер на вход вблизи плотности в заданном диапазоне NATR;
    - отправлять рыночный ордер при подходе цены к плотности;
    - отслеживать статусы ордеров (частичное исполнение, полное исполнение, отмена).
- **Надёжность**:
  - Описать стратегию ретраев при ошибках/таймаутах API.
  - Учитывать rate-limit Hyperliquid (backoff, очередь запросов).
  - Не реализовывать пока конкретные HTTP/WebSocket вызовы — только интерфейсы и флоу.

### Спринт 4 — Stop-loss

- **Постановка SL**:
  - SL ставится сразу после открытия позиции.
  - Уровень: «за 1 тик за крупной заявкой» по направлению риска:
    - Лонг от bid-плотности → SL ниже плотности на 1 тик.
    - Шорт от ask-плотности → SL выше плотности на 1 тик.
- **Детали**:
  - Учесть размер тика инструмента (tickSize).
  - Рассмотреть вариант OCO-ордеров (TP+SL).
  - Продумать поведение, если исходная крупная лимитка исчезла/переставилась (двигать SL или нет).
- **SL по «разъеданию» и снятию плотности**:
  - При входе по крупной заявке фиксировать её исходный размер (например, 1М$) и цену.
  - Ввести параметр (или жёсткое правило), что если остаток заявки падает до ≤ X% от начального объёма (например, 30%) или до абсолютного минимума (например, ≤ 300K$), позиция закрывается (рыночным или лимитным выходом согласно конфигу).
  - Реализовать отслеживание: отличать ситуацию, когда:
    - заявка частично съедена, но остаток всё ещё виден в стакане;
    - заявка полностью снята/съедена в зоне видимости спрэда;
    - заявка просто ушла за границы видимости (цена ушла дальше, а не снятие).
  - Правило выхода:
    - Если заявка в зоне видимости **пропала по этой цене** или остаток ≤ порога → форсированный выход из позиции.
    - Если заявка просто ушла из видимой зоны из-за движения цены, но всё ещё существует дальше по стакану → решение по выходу принимать отдельно (не считать это автоматическим сигналом для SL).

### Спринт 5 — Лесенка тейк-профитов по NATR

- **Разбиение позиции**:
  - Использовать массивы, вроде `TRADE_TP_NATR_LEVELS=[2,3]` и `TRADE_TP_PERCENTS=[50,50]`.
  - Интерпретация: закрыть 50% позиции на `entryPrice ± 2*NATR`, 50% — на `entryPrice ± 3*NATR` (знак зависит от направления позиции).
- **Поведение**:
  - Обработать частичные исполнения по каждому уровню.
  - Логика обновления/отмены оставшихся TP после изменения позиции (частичное закрытие вручную, стоп и т.д.).

### Спринт 5 — Пер-коиновый трейд-конфиг

- **Персональные настройки на монету**:
  - Спроектировать env-переменную `TRADE_OVERRIDES` или аналог, в стиле:
    - `TRADE_OVERRIDES=BTC:{posSizeUsd:20000,entryRange:[1,2],tpLevels:[2,3],tpPercents:[50,50]};ETH:{...}`
  - Либо использовать более простой строковый формат по аналогии с `MIN_ORDER_SIZE_USD_OVERRIDES`.
- **Приоритеты**:
  - Описать порядок применения: сначала per-coin override, затем глобальные настройки.

### Спринт 6 — Режимы безопасности и тестирования

- **Режимы**:
  - `TRADE_MODE=SCREEN_ONLY` — только алерты, без торговли.
  - `TRADE_MODE=TRADE_PAPER` — paper/dry-run: сделки логируются и эмулируются (без реальных ордеров).
  - `TRADE_MODE=TRADE_LIVE` — реальные ордера (вводить только после полного тестирования).
- **Ограничения и защита**:
  - Максимум сделок за день (`TRADE_DAILY_MAX_TRADES`).
  - Максимальный дневной убыток (`TRADE_DAILY_MAX_LOSS`) с авто-отключением торговли.
  - Ограничение числа одновременных позиций.
  - Защита от повторных входов в одну и ту же плотность/уровень.
  - Обработка ошибок Hyperliquid (reject, timeout, disconnect) и аварийный стоп торговли при аномалиях.

### Спринт 6 — Мониторинг и логирование для торгового модуля

- **Логи**:
  - Структурированные логи с полями: `component` (screener/trading), `symbol`, `orderId`, `positionId`, `side`, `size`, `price`, `risk`.
  - Разделить информационные/отладочные/ошибки по уровням.
- **Уведомления**:
  - Отдельный Telegram-канал/чат для торговых событий (открытие/закрытие позиций, ошибки, отключение торговли).
- **Метрики**:
  - PnL по дням/неделям.
  - Hit-rate (доля успешных сделок).
  - Средний вход/выход в единицах NATR.
  - Визуализация и экспорт (на будущее: Prometheus/Grafana или простые CSV/JSON отчёты).
  - Оценить, какие метрики нужны в первую очередь (минимальный набор для запуска `TRADE_LIVE`).

---

### Спринт 7 — Скринер крупных тиков и детектор роботов

**Цель:** отдельный режим/модуль, который смотрит **принты (trades)**, ищет поведение, похожее на робота, и шлёт алерты в Telegram.

- **Источник данных и базовый скринер** (Сложность: низкая–средняя):
  - Определить источник принтов по Hyperliquid (WS-канал trades).
  - Спроектировать структуру хранения последних принтов per-coin в небольшом буфере (кольцевой буфер по времени).
  - Добавить отдельный «режим скринера роботов» (например, `ROBOT_SCANNER_ENABLED`), независимый от основного скринера лимиток.

- **Детектор роботов по повторяющимся лотам** (Сложность: средняя):
  - Формальное определение «робота»:
    - N повторений **одинакового размера лота** (например, 1000 контрактов) в пределах заданного окна по времени.
    - Примеры: 3 одинаковых принта по 1000 лотов каждый, с интервалами ~1 сек.
  - ENV-конфиг:
    - `ROBOT_MIN_REPEATS` — минимальное количество повторений (например, 3).
    - `ROBOT_MAX_TIME_WINDOW_SEC` — максимальное окно по времени между первым и последним совпадением (например, 5 секунд).
    - Возможный доп. фильтр: `ROBOT_MIN_LOT_SIZE` в контрактах.
  - Логика:
    - Для каждого нового трейда проверять в окне `ROBOT_MAX_TIME_WINDOW_SEC`, сколько раз уже был такой же `size`.
    - При достижении `ROBOT_MIN_REPEATS` формировать сигнал «вероятный робот» по монете.

- **Алерты и формат сообщений** (Сложность: низкая):
  - Отдельный тип алерта в Telegram:
    - Монета, направление (buy/sell), размер лота, количество повторений, временной диапазон (начало/конец), примерная частота.
  - Настройки:
    - `ROBOT_ALERT_COOLDOWN_MS` — задержка между алертами по одному и тому же роботу (чтобы не спамить).
  - Структурированные логи для последующего анализа (component=`robot_scanner`).

- **Будущее расширение (не в первый релиз)**:
  - Более сложные паттерны (чередование buy/sell, лестницы по цене).
  - Кросс-анализ принтов и лимитных заявок (робот, который одновременно движет стакан и печатает тики).

---

### Спринт 8 — Арбитраж Hyperliquid ↔ Binance

**Цель:** использовать крупную лимитную заявку на Hyperliquid как якорь и торговать расхождение цен (spread) между Hyperliquid и Binance.

- **Базовая архитектура арбитражного модуля** (Сложность: высокая):
  - Отдельный модуль `ArbitrageEngine`, не завязанный жёстко на торговый модуль скринера, но использующий те же адаптеры:
    - `HyperliquidMarketData` / `HyperliquidTradingClient`.
    - `BinanceMarketData` / `BinanceTradingClient` (REST+WS, ключи/секреты через `.env`).
  - Режимы:
    - `ARBITRAGE_ENABLED` (bool).
    - Возможный `ARBITRAGE_MODE=PAPER/LIVE`.

- **Условия входа в арбитраж** (Сложность: средняя–высокая):
  - Условие **наличия крупной лимитной заявки на Hyperliquid** (использовать уже существующий скринер плотностей).
  - Проверка цены той же монеты на Binance:
    - Рассчитывать процентное расхождение цен `spread = (price_hl / price_binance - 1) * 100` (или наоборот).
  - ENV-конфиг:
    - `ARB_MIN_SPREAD_PERCENT` — минимальное расхождение (например, 0.3%).
    - `ARB_MAX_SPREAD_PERCENT` — максимальное рабочее расхождение (чтобы не лезть в явно аномальные ситуации).
    - `ARB_POSITION_SIZE_USD` — целевой размер арбитражной позиции.
    - `ARB_MIN_TRADE_USD` / `ARB_MAX_TRADE_USD` — диапазон объёма одной «кликации» (набор позиции частями).

- **Сценарии входа** (простая версия, Сложность: средняя):
  - Если **Hyperliquid дороже Binance**:
    - Открываем **short** на Hyperliquid, **long** на Binance.
  - Если **Hyperliquid дешевле Binance**:
    - Открываем **long** на Hyperliquid, **short** на Binance.
  - Вход может набираться **частями**:
    - Делить `ARB_POSITION_SIZE_USD` на несколько шагов внутри диапазона `ARB_MIN_TRADE_USD`–`ARB_MAX_TRADE_USD`.
    - На каждом шаге проверять актуальный spread и наличие лимитной заявки на Hyperliquid.

- **Выход из арбитража** (Сложность: средняя–высокая):
  - Базовый сценарий, который нужно описать в TODO до реализации:
    - На стороне, где была крупная лимитка (Hyperliquid), выходим **лимиткой** (например, выставляем ордер к этой же плотности или чуть внутри спреда).
    - На второй бирже (Binance) выходим **по рынку** на тот же объём, как только лимитка на Hyperliquid исполнилась (либо spread сошёлся).
  - ENV-настройки:
    - `ARB_EXIT_MODE_HL` / `ARB_EXIT_MODE_BINANCE` — где выходим лимитом, где маркетом.
    - `ARB_MAX_SPREAD_LOSS_PERCENT` — максимальное негативное расхождение (в %), при котором арбитраж принудительно закрывается (анти-скачивание).

- **Риск-менеджмент и ограничения** (Сложность: высокая):
  - Ограничения:
    - Максимальное количество одновременных арбитражных пар.
    - Максимальный общий размер позиций на каждой бирже.
    - Максимальный дневной убыток от арбитражных стратегий.
  - Учёт комиссий и funding (особенно на Hyperliquid, как перп DEX).
  - Обработка случаев:
    - Невозможность открыть позицию на одной из сторон (reject, нет ликвидности).
    - Дисконнект/лаг одной из бирж.

- **Приоритезация по сложности (от простого к сложному)**:
  1. **Арбитражный монитор без сделок**:
     - Считать spread HL↔Binance при наличии крупной лимитки, логировать потенциальные арбитражные ситуации и слать **только алерты**.
  2. **Paper-арбитраж**:
     - Эмулировать открытие/закрытие позиций и считать виртуальный PnL без реальных ордеров.
  3. **Малый live-арбитраж**:
     - Реально торговать маленькими объёмами с жёсткими лимитами риска и количества сделок.
  4. **Продвинутый live-арбитраж**:
     - Добавить набор позиции частями, умное распределение выхода (где лимит/где маркет), динамические лимиты по риску и дополнительную аналитику.

---

### Спринт 9 — Контекстное управление объёмом, риском и тейками ✅ ВЫПОЛНЕН

- **Факторы силы движения (шок по NATR)**: ✅
  - Ввести расчёт «шока» по NATR: сколько суммарно 5m NATR мы прошли за последние 30 минут / 1 час.
  - Конфиг уровня шока и мультипликаторов объёма: например,
    - `SHOCK_30M_LEVEL_1=6; SHOCK_30M_SIZE_MULT_1=1.0`,
    - `SHOCK_60M_LEVEL_2=12; SHOCK_60M_SIZE_MULT_2=2.0`.
  - На основе этих правил выбирать целевой `positionSizeUsd = TRADE_POSITION_SIZE_USD * shockMultiplier`.
  - **Реализовано**: `ContextFeaturesService` в `src/trading/contextFeatures.ts`.

- **Память по якорю (одна и та же лимитка)**: ✅
  - Вводим сущность «якорь» = (coin, anchorPrice, side), для которой считаем статистику:
    - количество завершённых сделок по этому якорю,
    - количество взятых тейков (успешных трейдов),
    - время последнего касания/сделки.
  - Правила:
    - если от якоря уже было N профитных сделок (например, 5) → больше **не торговать** от этого уровня;
    - если есть закрытая сделка по этому якорю, и мы снова подходим к нему через X часов →
      уменьшать объём (например, множитель 0.5) и/или делать тейки ближе (уменьшать NATR уровни).
  - **Реализовано**: `AnchorMemory` в `src/trading/anchorMemory.ts`, хранение в JSON файле.

- **Адаптация тейков во времени (стояние у плотности)**: ✅
  - Для каждой открытой позиции хранить `timeSinceEntry` и `timeInAnchorZone` (сколько времени мы провели возле якорной цены без тейка).
  - Конфиг: если `timeInAnchorZone > 40 мин` и ни один TP не был достигнут:
    - сдвигать все оставшиеся TP ближе (например, умножать уровни NATR на 0.5–0.7);
    - либо добавлять дополнительный «time-based TP», который закроет часть/всю позицию.
  - **Реализовано**: Правило `long_time_near_anchor` в `policy.example.yaml`.

- **Гибкая система правил (policy-движок)**: ✅
  - Вынести все такие условия в конфиг уровня «правил» (policy), например в JSON/YAML:
    - список правил вида: `if <условия по NATR / времени / кол-ву сделок по якорю> → <множители размера / TP / SL>`.
  - Минимальный интерфейс:
    - модуль `ContextFeatures` считает фичи: `shock30m`, `shock60m`, `anchorRetestCount`, `anchorWins`, `timeInZone`, `timeSinceLastTrade`.
    - модуль `PositionPolicy` читает конфиг правил и на входе фичи → на выходе выдаёт:
      - `sizeMultiplier`, `tpLevelsMultiplier`, `maxTradesPerAnchor`, дополнительные ограничения по риску.
  - Конфиг можно хранить:
    - либо в `.env` как одну/несколько JSON-строк,
    - либо в отдельном `policy.json`/`strategy.json`, путь к которому задаётся через `.env`.
  - **Реализовано**: 
    - `PolicyRulesParser` в `src/trading/policyRules.ts` для парсинга YAML;
    - `PositionPolicy` в `src/trading/positionPolicy.ts` применяет правила из YAML;
    - Примеры правил в `policy.example.yaml`;
    - Конфиг `POLICY_RULES_FILE` для указания пути к YAML файлу.

- **Ограничения на число сделок от одной лимитки**: ✅
  - Добавить счётчик по якорю: если `anchorWins >= MAX_WINS_PER_ANCHOR` (например, 5) → новые сигналы от этого уровня игнорируются.
  - Порог задавать в конфиге, например `MAX_WINS_PER_ANCHOR=5`.
  - **Реализовано**: Правило `too_many_wins_on_anchor` в `policy.example.yaml`, конфиг `POLICY_MAX_WINS_PER_ANCHOR`.

- **Примеры правил (реализовано в `policy.example.yaml`)**: ✅

См. файл `policy.example.yaml` для полного списка правил с комментариями. Основные правила:

1. **too_many_wins_on_anchor** (priority: 1) - блокировка якоря после 5 профитных сделок
2. **shock_30m_normal** (priority: 10) - базовый размер при шоке 30м
3. **shock_60m_strong** (priority: 9) - удвоенный размер при сильном шоке 60м
4. **anchor_retest_smaller** (priority: 8) - уменьшенный размер при ретесте через 3+ часа
5. **long_time_near_anchor** (priority: 7) - подтягивание TP при долгом стоянии у якоря

**Структура правила**:
```yaml
- name: уникальное_имя
  priority: число (меньше = выше приоритет)
  scope: new_entry | open_position | new_entry_breakdown
  when:
    # условия (все должны выполняться)
    shock30mNatrGte: 6
    anchorWinCountGte: 5
    # и т.д.
  then:
    # действия
    allowTrade: false  # или true
    sizeMultiplier: 1.5
    tpNatrMultiplier: 1.2
    slNatrMultiplier: 1.0
```

Для создания собственных правил скопируйте `policy.example.yaml` → `policy.yaml` и настройте по необходимости.

---

### Спринт 10 — Стратегия разъедания плотностей (breakdown от крупной лимитки)

- **Сигнал «разъедание» (breakdown) вместо отскока**:
  - Отдельный тип сигнала, когда крупная лимитка быстро съедается:
    - фиксируем `anchorInitialValueUsd` (например, 1M$) при появлении лимитки;
    - наблюдаем за остатком в окне `EAT_WINDOW_MS` (например, 4000 мс);
    - если за это время остаток падает до `≤ anchorInitialValueUsd * (1 - EAT_FRACTION)` (например, 80% съели) **и/или** ниже абсолютного порога `EAT_MIN_REMAIN_USD` (например, 200k$) — генерируем breakdown‑сигнал.
  - Конфиг для стратегии разъедания:
    - `EAT_MIN_INITIAL_USD` — минимальный исходный размер плотности, чтобы стратегия вообще активировалась;
    - `EAT_FRACTION` — доля съеденной плотности (например, 0.8);
    - `EAT_WINDOW_MS` — окно по времени (например, 4000 мс);
    - `EAT_MIN_REMAIN_USD` — абсолютный остаток, при котором считаем, что лимитку «продавили».

- **Направление сделки**:
  - Если разъедают **лонговую** лимитку (bid) → открываем **шорт** (играем в сторону пробоя вниз).
  - Если разъедают **шортовую** лимитку (ask) → открываем **лонг** (пробой вверх).
  - Важно отделить эту стратегию от bounce‑логики (отскоки) флагами:
    - `STRATEGY_BOUNCE_ENABLED=true/false`;
    - `STRATEGY_BREAKDOWN_ENABLED=true/false`.

- **TP и SL для breakdown‑сделки**:
  - Тейки:
    - использовать ту же NATR‑лесенку, что и сейчас (`TRADE_TP_NATR_LEVELS`, `TRADE_TP_PERCENTS`);
    - дополнительно разрешить override для стратегии разъедания, например:
      - `EAT_TP_NATR_LEVELS`, `EAT_TP_PERCENTS` (если заданы — имеют приоритет для breakdown‑сделок).
  - Стоп‑лосс:
    - обычный SL по NATR/цене (например, `EAT_SL_NATR_MULT` или `EAT_SL_TICKS`);
    - плюс временной SL:
      - если прошло `EAT_TIME_SL_MS` (например, 10000 мс) с момента входа, а ни один TP не сработал и цена не ушла достаточно в нашу сторону — закрываем по рынку (time‑based SL).

- **Интеграция в policy‑движок**:
  - Для breakdown‑сигналов использовать отдельный `scope` или `strategy`:

```yaml
  - name: breakdown_big_eat
    scope: new_entry_breakdown
    when:
      eatFractionGte: 0.8
      eatWindowMsLte: 4000
    then:
      sizeMultiplier: 1.5
      tpNatrMultiplier: 0.8   # тейки ближе, т.к. вход агрессивный
      maxTradesPerAnchor: 2
```

- **Общее поведение**:
  - Для каждого якоря (лимитки) считать и отскоковые, и breakdown‑сигналы, но входить только по активированным стратегиям (`*_ENABLED`).
  - Переиспользовать уже существующую инфраструктуру:
    - `anchorInitialValueUsd`, `anchorMinValueUsd` (для SL по разъеданию),
    - учёт количества трейдов/тейков по якорю из Спринта 9, чтобы не зацикливаться на одной лимитке.
